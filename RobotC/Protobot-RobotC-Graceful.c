#pragma config(Motor,  port2,           LeftDrive,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RightDrive,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Arm,           tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* This file contains a graceful version of the Protobot RobotC code.
* This code is an idealistic one that prioritizes convention and failsafes over efficency.
* If you are an advanced user, this would probably be the better one to follow.
* Beginners should look at the EasyC or Protobot-RobotC-Basic.c
*/


/**
* Since RobotC does not have built in documentation genertation, comments
* will be formatted in JavaDOC, as that is the convention used by Team 100 in production robot code.
*/

/////////////////////////////////////////
//              VARIABLES              //
/////////////////////////////////////////

// These variables are what motor powers are assigned to.
signed char dtLeftPower = 0;
signed char dtRightPower = 0;
signed char intakePower = 0;
signed char armPower = 0;

// These variables are used to specify the power that intake and outtake occurs at.
signed char intakeDefinedPower = 60;
signed char outtakeDefinedPower = -60;

signed char armUpPower = 127;
signed char armDownPower = -40;

signed char leftVericalValue = 0; // CH3
signed char leftHorizontalValue = 0; // CH4
signed char rightVericalValue = 0; // Ch2
signed char rightHorizontalValue = 0; // Ch 1

// Represent the states of joystick buttons. The values returned by the function is `word` not `bool`,
// but they can be compared like a boolean
word armUpPressed;
word armDownPressed;

word intakePressed;
word outtakePressed;

// Determines if the robot should stay alive or die. FALSE = dies gracefully
bool stayAlive = true;

/**
* Sets the sensor value env variables to the current values
*/
void getSensorValues(){
	// Since we don't have any sensors currently, this doesn't matter.
}

/**
* Sets the joystick value env variables to the current values
*/
void getJoystickValues()
{
	leftVericalValue = vexRT[Ch3];
	leftHorizontalValue = vexRT[Ch4];
	rightVericalValue = vexRT[Ch2];
	rightHorizontalValue = vexRT[Ch1];

	armUpPressed = vexRT[Btn6U];
	armDownPressed = vexRT[Btn6D];

	intakePressed = vexRT[Btn5U];
	outtakePressed = vexRT[Btn5D];
}



/**
* This function handles arcade drive. It is based on an article by VRC Team 1666, Renegade Robotics
* that can be seen at https://renegaderobotics.org/robotc-chassis-programming/.
*
* The math for this comes from the Renegade Robotics Article. In the 2018 and 2019 seasons, Team 100
* used this article from Renegade Robotics to develop a 'synthetic arcade drive' that does not rely
* on the functions created by the people who write FRC robot libraries.
*/
void arcade()
{
	dtLeftPower = (vexRT[Ch3] + vexRT[Ch4]);
	dtRightPower = (vexRT[Ch3] - vexRT[Ch4]);

}

/**
* This function handles tank drive. It takes the raw joystick values and assign it to the left and right power.
*/
void tank()
{
	dtLeftPower = vexRT[Ch2]; // This sets the left power to the value of the left joystick
	dtRightPower = vexRT[Ch3]; // This sets the right power to the value of the right joystick

}

/**
* This function is called when an intake should occur. It sets the power to the prespecified value
*/
void processIntake()
{
	intakePower = intakeDefinedPower;
}

/**
* This function is called when an outtake should occur. It sets the power to the prespecified value
*/
void processOuttake()
{
	intakePower = outtakeDefinedPower;
}

/**
* This function is called when the intake should stop or continue to stay stopped.
* It sets the power to 0
*/
void zeroIntakeMotors()
{
	intakePower = 0;
}

/**
* Determines whether the intake should intake, outtake, or stop based on joystick values.
* Priority is given to Intake
*/
void processIntakeOuttake()
{
	if(intakePressed){
		processIntake();
	}
	else if(outtakePressed){
		processOuttake();
	}
	else{
		zeroIntakeMotors();
	}

}




/**
* This function is called when the arm should move up. It sets the power to the prespecified value
*/
void processArmUp()
{
	armPower = armUpPower;
}

/**
* This function is called when the arm should move down. It sets the power to the prespecified value
*/
void processArmDown()
{
	armPower = armDownPower;
}

/**
* This function is called when the intake should stop or continue to stay stopped.
* It sets the power to 0
*/
void zeroArmMotors()
{
	armPower = 0;
}

/**
* Determines whether the arm should move up, down, or stop based on joystick values.
* Priority is given to up
*/
void processArm()
{
	if(armUpPressed){
		processArmUp();
	}
	else if(armDownPressed){
		processArmDown();
	}
	else{
		zeroArmMotors();
	}
}

/**
* Sets the motors to the determined value. This helps with
* debugging and alleviates motor conflict.
* Learn more at https://renegaderobotics.org/set-motor-power-just-once/
*/
void setMotorPowers()
{
	motor[LeftDrive] = dtLeftPower;
	motor[RightDrive] = dtRightPower;
	motor[Arm] = armPower;
	motor[Intake] = intakePower;

}


/**
* This runs the code for every loop.
* When the function returns false, the process can shut down
* The purpose of a boolean is to allow for a graceful shutdown
*
* @return whether the loop should run again
*/
bool runLoop()
{
	getSensorValues();
	getJoystickValues();
	//arcade();
	tank();
	processIntakeOuttake();
	processArm();
	setMotorPowers();
	return stayAlive;

}

/**
* This function processes a graceful death. A graceful death ensures
* that the robot is in a safe location without errors or overflow
* should the robot be intended to shut down.
*/
void die()
{
	// In its current form, all motors are set to zero.
	dtLeftPower = 0;
	dtRightPower = 0;
	armPower = 0;
	intakePower = 0;
	setMotorPowers();
}

/**
* This code will be run by the Cortex on enable.
* It runs the loop every time, waiting for a graceful shutdown
*/
task main()
{
	bool run = true;
	while(run){
		run = runLoop();
	}
	die();

}
