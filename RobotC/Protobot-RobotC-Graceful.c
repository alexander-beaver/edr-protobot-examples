#pragma config(Motor,  port2,           Arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           Intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightDrive,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port7,           LeftDrive,     tmotorVex393_MC29, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* This file contains a graceful version of the Protobot RobotC code.
* This code is an idealistic one that prioritizes convention and failsafes over efficency.
* If you are an advanced user, this would probably be the better one to follow.
* Beginners should look at the EasyC or Protobot-RobotC-Basic.c
*/


/**
* Since RobotC does not have built in documentation genertation, comments
* will be formatted in JavaDOC, as that is the convention used by Team 100 in production robot code.
*/

/////////////////////////////////////////
//              VARIABLES              //
/////////////////////////////////////////

// These variables are what motor powers are assigned to.
signed char dtLeftPower = 0;
signed char dtRightPower = 0;
signed char intakePower = 0;
signed char armPower = 0;

// These variables are used to specify the power that intake and outtake occurs at.
signed char intakeDefinedPower = 60;
signed char outtakeDefinedPower = -60;

signed char armUpPower = 60;
signed char armDownPower = -60;

signed char leftVericalValue = 0; // CH3
signed char leftHorizontalValue = 0; // CH4
signed char rightVericalValue = 0; // Ch2
signed char rightHorizontalValue = 0; // Ch 1

word armUpPressed;
word armDownPressed;

word intakePressed;
word outtakePressed;

bool stayAlive = true;


void getJoystickValues()
{
	leftVericalValue = vexRT[Ch3];
	leftHorizontalValue = vexRT[Ch4];
	rightVericalValue = vexRT[Ch2];
	rightHorizontalValue = vexRT[Ch1];

	armUpPressed = vexRT[Btn6U];
	armDownPressed = vexRT[Btn6D];

	intakePressed = vexRT[Btn5U];
	outtakePressed = vexRT[Btn5D];
}



/**
* This function handles arcade drive. It is based on an article by VRC Team 1666, Renegade Robotics
* that can be seen at https://renegaderobotics.org/robotc-chassis-programming/.
*
* The math for this comes from the Renegade Robotics Article. In the 2018 and 2019 seasons, Team 100
* used this article from Renegade Robotics to develop a 'synthetic arcade drive' that does not rely
* on the functions created by the people who write FRC robot libraries.
*/
void arcade()
{
	dtLeftPower = (vexRT[Ch3] + vexRT[Ch4]);
	dtRightPower = (vexRT[Ch3] - vexRT[Ch4]);

}

/**
* This function handles tank drive. It takes the raw joystick values and assign it to the left and right power.
*/
void tank()
{
	dtLeftPower = vexRT[Ch2]; // This sets the left power to the value of the left joystick
	dtRightPower = vexRT[Ch3]; // This sets the right power to the value of the right joystick

}


void processIntake()
{
	intakePower = intakeDefinedPower;
}

void processOuttake()
{
	intakePower = outtakeDefinedPower;
}

void zeroIntakeMotors()
{
	intakePower = 0;
}

void processIntakeOuttake()
{
	if(intakePressed){
		processIntake();
	}
	else if(outtakePressed){
		processOuttake();
	}
	else{
		zeroIntakeMotors();
	}

}





void processArmUp()
{
	armPower = armUpPower;
}
void processArmDown()
{
	armPower = armDownPower;
}
void zeroArmMotors()
{
	armPower = 0;
}

void processArm()
{
	if(armUpPressed){
		processArmUp();
	}
	else if(armDownPressed){
		processArmDown();
	}
	else{
		zeroArmMotors();
	}
}


void setMotorPowers()
{
	motor[LeftDrive] = dtLeftPower;
	motor[RightDrive] = dtRightPower;
	motor[Arm] = armPower;
	motor[Intake] = intakePower;

}


/**
* This runs the code for every loop.
* When the function returns false, the process can shut down
* The purpose of a boolean is to allow for a graceful shutdown
*
* @return whether the loop should run again
*/
bool runLoop()
{
	getJoystickValues();
	arcade();
	//tank();
	processIntakeOuttake();
	processArm();
	setMotorPowers();
	return stayAlive;

}


void die()
{
	//Code for a graceful death happens here
}
/**
* This code will be run by the Cortex on enable.
* It runs the loop every time, waiting for a graceful shutdown
*/
task main()
{
	bool run = true;
	while(run){
		run = runLoop();
	}
	die();

}
